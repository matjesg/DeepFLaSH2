# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/01_models.ipynb (unless otherwise specified).

__all__ = ['ARCHITECTURES', 'ENCODERS', 'get_pretrained_options', 'create_smp_model', 'save_smp_model',
           'load_smp_model', 'MultiSegmentationHead']

# Cell
import torch
import segmentation_models_pytorch as smp

# Cell
# https://github.com/qubvel/segmentation_models.pytorch#architectures-
ARCHITECTURES =  ['Unet', 'UnetPlusPlus', 'FPN', 'PAN', 'PSPNet', 'Linknet', 'DeepLabV3', 'DeepLabV3Plus'] #'MAnet',

# https://github.com/qubvel/segmentation_models.pytorch#encoders-
ENCODERS = [*smp.encoders.encoders.keys()]

# Cell
def get_pretrained_options(encoder_name):
    'Return available options for pretrained weights for a given encoder'
    options = smp.encoders.encoders[encoder_name]['pretrained_settings'].keys()
    return [*options, None]

# Cell
def create_smp_model(arch, **kwargs):
    'Create segmentation_models_pytorch model'

    assert arch in ARCHITECTURES, f'Select one of {ARCHITECTURES}'

    if arch=="Unet": model =  smp.Unet(**kwargs)
    elif arch=="UnetPlusPlus": model = smp.UnetPlusPlus(**kwargs)
    elif arch=="MAnet":model = smp.MAnet(**kwargs)
    elif arch=="FPN": model = smp.FPN(**kwargs)
    elif arch=="PAN": model = smp.PAN(**kwargs)
    elif arch=="PSPNet": model = smp.PSPNet(**kwargs)
    elif arch=="Linknet": model = smp.Linknet(**kwargs)
    elif arch=="DeepLabV3": model = smp.DeepLabV3(**kwargs)
    elif arch=="DeepLabV3Plus": model = smp.DeepLabV3Plus(**kwargs)
    else: raise NotImplementedError

    setattr(model, 'kwargs', kwargs)
    return model

# Cell
def save_smp_model(model, arch, file,  stats=None, pickle_protocol=2):
    'Save smp model, optionally including  stats'
    state = model.state_dict()
    save_dict = {'model': state, 'arch': arch, 'stats': stats, **model.kwargs}
    torch.save(save_dict, file, pickle_protocol=pickle_protocol, _use_new_zipfile_serialization=False)

# Cell
def load_smp_model(file, device=None, strict=True, **kwargs):
    'Loads smp model from file '
    if isinstance(device, int): device = torch.device('cuda', device)
    elif device is None: device = 'cpu'
    model_dict = torch.load(file, map_location=device)
    state = model_dict.pop('model')
    stats = model_dict.pop('stats')
    model = create_smp_model(**model_dict)
    model.load_state_dict(state, strict=strict)
    return model, stats

# Cell
from torch import nn
from fastcore.basics import patch
from segmentation_models_pytorch.unet.decoder import UnetDecoder
from segmentation_models_pytorch.encoders import get_encoder
from segmentation_models_pytorch.base import SegmentationModel
from segmentation_models_pytorch.base import SegmentationHead, ClassificationHead

# Cell
class MultiSegmentationHead(nn.Module):
    def __init__(self, heads):
        super().__init__()
        self.heads = [SegmentationHead(**head) for head in heads]

    def forward(self, xs):
        for head in self.heads: head.to(xs[0])
        return [head(x) for head, x in zip(self.heads, xs)]

# Cell
@patch
def forward(self:smp.unet.decoder.UnetDecoder, *features):

    seg_outputs = []
    features = features[1:]    # remove first skip with same spatial resolution
    features = features[::-1]  # reverse channels to start from head of encoder

    head = features[0]
    skips = features[1:]

    x = self.center(head)
    for i, decoder_block in enumerate(self.blocks):
        skip = skips[i] if i < len(skips) else None
        x = decoder_block(x, skip)
        seg_outputs.append(x)

    #if self.deep_supervision:
    return seg_outputs[::-1]


    #else:
    #    return seg_outputs[-1]

# Cell
from typing import Optional, Union, List
@patch
def __init__(
    self:smp.unet.model.Unet,
    encoder_name: str = "resnet34",
    encoder_depth: int = 5,
    encoder_weights: Optional[str] = "imagenet",
    decoder_use_batchnorm: bool = True,
    decoder_channels: List[int] = (256, 128, 64, 32, 16),
    decoder_attention_type: Optional[str] = None,
    in_channels: int = 3,
    classes: int = 1,
    activation: Optional[Union[str, callable]] = None,
    aux_params: Optional[dict] = None,
    deep_supervision:bool = True,
):
    super(smp.unet.model.Unet, self).__init__()

    self.encoder = get_encoder(
        encoder_name,
        in_channels=in_channels,
        depth=encoder_depth,
        weights=encoder_weights,
    )

    self.decoder = UnetDecoder(
        encoder_channels=self.encoder.out_channels,
        decoder_channels=decoder_channels,
        n_blocks=encoder_depth,
        use_batchnorm=decoder_use_batchnorm,
        center=True if encoder_name.startswith("vgg") else False,
        attention_type=decoder_attention_type,
    )

    if deep_supervision:
        self.segmentation_head = MultiSegmentationHead(
            [{
            "in_channels":in_channels,
            "out_channels":classes,
            "activation":activation,
            "kernel_size":3
            } for head, in_channels in enumerate(decoder_channels[::-1])]
        )

    else:
        self.segmentation_head = SegmentationHead(
            in_channels=decoder_channels[-1],
            out_channels=classes,
            activation=activation,
            kernel_size=3,
        )


    if aux_params is not None:
        self.classification_head = ClassificationHead(
            in_channels=self.encoder.out_channels[-1], **aux_params
        )
    else:
        self.classification_head = None

    self.name = "u-{}".format(encoder_name)
    self.initialize()